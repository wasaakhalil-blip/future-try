package net.fxgear.b;

import android.graphics.Bitmap;
import android.graphics.Rect;
import android.opengl.GLES20;
import android.opengl.Matrix;
import android.util.Log;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import javax.microedition.khronos.opengles.GL10;
import net.fxgear.GlobalDefine;
import net.fxgear.b.h;
import net.fxgear.fittingview.qlSolver;
import net.fxgear.util.FXUtil;

/* compiled from: FXRenderer */
public class m {
    private FloatBuffer A;
    private FloatBuffer B;
    private int C = -1;
    private int D = -1;
    private int E = 0;
    private long F = 0;
    private double G = -1.0d;
    private int H;
    private int I;
    private int J;
    private int K;
    private int[] L = new int[this.v.length];
    private int M;
    private final int N = 0;
    private final int O = 1;
    private final int P = 2;
    private final int Q = 3;
    private final int R = 4;
    private final int S = 5;
    private final int T = 6;
    private final int U = 7;
    private final int V = 8;
    private final int W = 9;
    private final int X = 10;
    private final int Y = 11;
    private float Z = GlobalDefine.DEFAULT_AUTO_FILTER_VALUE;

    /* renamed from: a  reason: collision with root package name */
    float[] f701a = new float[16];
    private int aA = -1;
    private int aB = -1;
    private int aC = -1;
    private int aD = -1;
    private int aE = -1;
    private int aF = -1;
    private int aG = -1;
    private int aH = -1;
    private int aI = -1;
    private int aJ = -1;
    private int aK = -1;
    private int aL = -1;
    private int aM = -1;
    private int aN = -1;
    private int aO = -1;
    private int aP = -1;
    private int aQ = -1;
    private int aR = -1;
    private int aS = -1;
    private int aT = -1;
    private int aU = -1;
    private int aV = -1;
    private int aW = -1;
    private int aX = -1;
    private int aY = -1;
    private int aZ = -1;
    private float aa = GlobalDefine.DEFAULT_AUTO_FILTER_VALUE;
    private float ab = GlobalDefine.DEFAULT_AUTO_FILTER_VALUE;
    private float ac = 200.0f;
    private int ad = 0;
    private int ae = -1;
    private final float af = 15.0f;
    private float ag = GlobalDefine.DEFAULT_AUTO_FILTER_VALUE;
    private float ah = GlobalDefine.DEFAULT_AUTO_FILTER_VALUE;
    private float ai = 1.0f;
    private float aj = GlobalDefine.DEFAULT_AUTO_FILTER_VALUE;
    private final float ak = -1000.0f;
    private final float al = 1000.0f;
    private final float am = GlobalDefine.DEFAULT_AUTO_FILTER_VALUE;
    private final float an = 199.5f;
    private final float ao = 205.0f;
    private final float ap = 215.0f;
    private final float aq = 200.5f;
    private final float ar = 225.0f;
    private final float as = 1000.0f;
    private h.e at = h.e.AVATAR;
    private int au = 0;
    private float av = GlobalDefine.DEFAULT_AUTO_FILTER_VALUE;
    private float[] aw = {1.0f, 1.0f, 1.0f, 1.0f};
    private float[] ax = {GlobalDefine.DEFAULT_AUTO_FILTER_VALUE, 1.0f, 1.0f, 1.0f};
    private int ay = -1;
    private int az = -1;

    /* renamed from: b  reason: collision with root package name */
    float[] f702b = new float[16];
    private int[] bA = new int[this.v.length];
    private int[] bB = new int[this.v.length];
    private int[] bC = new int[this.v.length];
    private int[] bD = new int[this.v.length];
    private int[] bE = new int[this.v.length];
    private final float bF = 0.3f;
    private Rect bG = new Rect();
    private qlSolver bH = null;
    private int ba = -1;
    private int bb = -1;
    private int bc = -1;
    private int bd = -1;
    private int be = -1;
    private int bf = -1;
    private int bg = -1;
    private int bh = -1;
    private int bi = -1;
    private int bj = -1;
    private int bk = -1;
    private int bl = -1;
    private int bm = -1;
    private int bn = -1;
    private int[] bo = new int[this.v.length];
    private int[] bp = new int[this.v.length];
    private int[] bq = new int[this.v.length];
    private int[] br = new int[this.v.length];
    private int[] bs = new int[this.v.length];
    private int[] bt = new int[this.v.length];
    private int[] bu = new int[this.v.length];
    private int[] bv = new int[this.v.length];
    private int[] bw = new int[this.v.length];
    private int[] bx = new int[this.v.length];
    private int[] by = new int[this.v.length];
    private int[] bz = new int[this.v.length];
    float[] c = {0.9f, 0.9f, 0.9f, 0.9f};
    float[] d = new float[16];
    int e = 75;
    float f = 1.0f;
    float g = 1.0f;
    float h = 1.0f;
    final float i = 15.0f;
    float[] j = new float[344];
    float[] k = new float[344];
    boolean l = false;
    private final String m = "precision lowp float; \nuniform mat4   uMVPMatrix;\nattribute vec4 aPosition;\nattribute vec2 a_tex_coord;\nvarying vec2   v_tex_coord;\nuniform float  uXScale; \nvoid main() \n{ \n   v_tex_coord = vec2(a_tex_coord.x, 1.0 - a_tex_coord.y); \n   gl_Position = uMVPMatrix * aPosition; \n   gl_Position.x *= uXScale; \n} \n";
    private final String n = "#extension GL_OES_EGL_image_external : require \nprecision lowp float; \nuniform samplerExternalOES sTexture; \nvarying vec2  v_tex_coord; \nvoid main() \n{ \n   gl_FragColor = texture2D(sTexture, v_tex_coord); \n} \n";
    private final String o = "precision lowp float; \nuniform mat4   uMVPMatrix;\nattribute vec4 aPosition;\nattribute vec2 a_tex_coord;\nvarying vec2   v_tex_coord;\nvoid main() \n{ \n   v_tex_coord = vec2(a_tex_coord.x, 1.0 - a_tex_coord.y); \n   gl_Position = uMVPMatrix * aPosition; \n} \n";
    private final String p = "precision lowp float; \nuniform sampler2D sTexture; \nvarying vec2  v_tex_coord; \nvoid main() \n{ \n   gl_FragColor = texture2D(sTexture, v_tex_coord); \n} \n ";
    private final String q = "precision highp float; \nuniform mat4   uMVPMatrix; \nuniform mat4   uROTMatrix; \nuniform vec4   uRealDQ[90]; \nuniform vec4   uDualDQ[90]; \nattribute vec4 aBoneWeight; \nattribute vec4 aBoneIndex; \nattribute vec2 aPartIndex; \nattribute vec4 aPosition; \nattribute vec2 aTexCoord; \nattribute vec3 aNormal; \nattribute float aStrain; \nattribute float aPressure; \nvarying float vStrain;varying float vPressure;varying vec2   vTexCoord; \nvarying vec2   vPart; \nuniform float  uYTrans; \nuniform float  uXTrans; \nuniform float  uXScale; \nuniform float  uHeadScale; \nuniform vec3   uHeadJointPos; \nuniform int    uHeadJointIndex; \nuniform vec2   uImageTrans; \nvoid main() \n{ \n   vec4 blendRealDQ = vec4(0.0); \n   vec4 blendDualDQ = vec4(0.0); \n   float neckScale = 0.0; \n   float neckScaleValue = 1.0; \n   if(int(aBoneIndex.x) == uHeadJointIndex) { neckScaleValue += (uHeadScale-1.0)*aBoneWeight.x; neckScale = 1.0;} \n   if(int(aBoneIndex.y) == uHeadJointIndex) { neckScaleValue += (uHeadScale-1.0)*aBoneWeight.y; neckScale = 1.0;} \n   if(int(aBoneIndex.z) == uHeadJointIndex) { neckScaleValue += (uHeadScale-1.0)*aBoneWeight.z; neckScale = 1.0;} \n   if(int(aBoneIndex.w) == uHeadJointIndex) { neckScaleValue += (uHeadScale-1.0)*aBoneWeight.w; neckScale = 1.0;} \n   blendRealDQ += aBoneWeight.x * uRealDQ[int(aBoneIndex.x)]; \n   blendRealDQ += aBoneWeight.y * uRealDQ[int(aBoneIndex.y)]; \n   blendRealDQ += aBoneWeight.z * uRealDQ[int(aBoneIndex.z)]; \n   blendRealDQ += aBoneWeight.w * uRealDQ[int(aBoneIndex.w)]; \n   blendDualDQ += aBoneWeight.x * uDualDQ[int(aBoneIndex.x)]; \n   blendDualDQ += aBoneWeight.y * uDualDQ[int(aBoneIndex.y)]; \n   blendDualDQ += aBoneWeight.z * uDualDQ[int(aBoneIndex.z)]; \n   blendDualDQ += aBoneWeight.w * uDualDQ[int(aBoneIndex.w)]; \n   float len = length(blendRealDQ); \n   blendRealDQ /= len; \n   blendDualDQ /= len; \n   vec3 pos = aPosition.xyz; \n   pos.y += uYTrans; \n   pos.x += sign(pos.x)*uXTrans;\n   if(neckScale > 0.5 && neckScaleValue != 1.0) {pos -= uHeadJointPos; pos *= neckScaleValue; pos += uHeadJointPos;} \n   pos = pos.xyz + 2.0*cross(blendRealDQ.xyz, cross(blendRealDQ.xyz, pos.xyz) + blendRealDQ.w*pos.xyz); \n   pos += 2.0*(blendRealDQ.w*blendDualDQ.xyz - blendDualDQ.w*blendRealDQ.xyz + cross(blendRealDQ.xyz, blendDualDQ.xyz)); \n   gl_Position = uMVPMatrix * vec4(pos, 1.0); \n   vTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y); \n   vPart = aPartIndex; \n   vStrain = 10.0*aStrain;\n   vPressure = 10.0*aPressure;\n   gl_Position.x *= uXScale;\n   gl_Position.xy += uImageTrans;\n} \n";
    private final String r = "precision lowp float; \nuniform int        uStrainMode;\nuniform vec3       uMaterial; \nuniform vec3       uTone; \nuniform sampler2D  sTexture; \nuniform sampler2D  sTextureHighlight; \nuniform float      uArmFilterMin; \nuniform float      uArmFilterMax; \nuniform float      uShoulderLengthMin; \nuniform float      uShoulderLengthMax; \nuniform int        uHighlightMode; \nuniform int        uDrawPart; \nuniform vec3       uTensionColor; \nuniform vec3       uPressureColor; \nvarying vec2       vTexCoord; \nvarying vec2       vPart; \nvarying float       vStrain;varying float       vPressure;void main() \n{ \n   { \n       if(vPart.r > uArmFilterMax || vPart.r < uArmFilterMin) discard;\n       if(uDrawPart == 1 && vPart.r > 199.5) discard; \n       if(abs(vPart.g) > uShoulderLengthMax || abs(vPart.g) < uShoulderLengthMin) \n       { \n           if(uDrawPart == 1) discard; \n           if(uDrawPart == 2 && vPart.r < 199.5) discard; \n       } \n   } \n   vec4 mainColor = texture2D(sTexture, vTexCoord); \n   if(mainColor.a < 0.5) discard; \n   if(uStrainMode==0)\n   {\n   float mainLumi = (mainColor.r + mainColor.g + mainColor.b)/3.0; \n   mainColor.rgb *= uTone; \n   float tonedLumi = (mainColor.r + mainColor.g + mainColor.b)/3.0; \n   mainColor.rgb *= mainLumi/tonedLumi; \n   gl_FragColor = mainColor; \n   if(uHighlightMode == 1) \n   { \n       vec4 colorMask = texture2D(sTextureHighlight, vTexCoord); \n       gl_FragColor.rgb += colorMask.a*colorMask.rgb; \n   } \n   } else if(uStrainMode==1)\n   {\n   gl_FragColor = vec4((1.0-vStrain)*mainColor.rgb + vStrain*uTensionColor, mainColor.a*0.7); \n   } else if(uStrainMode==2)\n   {\n   gl_FragColor = vec4((1.0-vPressure)*mainColor.rgb + vPressure*uPressureColor, mainColor.a*0.7); \n   }\n} \n";
    private final String s = "precision highp float; \nuniform mat4   uMVPMatrix; \nuniform mat4   uROTMatrix; \nuniform vec4   uRealDQ[90]; \nuniform vec4   uDualDQ[90]; \nattribute vec4 aBoneWeight; \nattribute vec4 aBoneIndex; \nattribute vec4 aPosition; \nattribute vec2 aTexCoord; \nattribute vec3 aNormal; \nvarying vec2   vTexCoord; \nuniform float  uYTrans; \nuniform float  uHeadScale; \nuniform vec3   uHeadJointPos; \nuniform vec2   uImageTrans; \nvoid main() \n{ \n   vec4 blendRealDQ = vec4(0.0); \n   vec4 blendDualDQ = vec4(0.0); \n   float neckScale = 0.0; \n   float neckScaleValue = uHeadScale; \n   blendRealDQ += aBoneWeight.x * uRealDQ[int(aBoneIndex.x)]; \n   blendRealDQ += aBoneWeight.y * uRealDQ[int(aBoneIndex.y)]; \n   blendRealDQ += aBoneWeight.z * uRealDQ[int(aBoneIndex.z)]; \n   blendRealDQ += aBoneWeight.w * uRealDQ[int(aBoneIndex.w)]; \n   blendDualDQ += aBoneWeight.x * uDualDQ[int(aBoneIndex.x)]; \n   blendDualDQ += aBoneWeight.y * uDualDQ[int(aBoneIndex.y)]; \n   blendDualDQ += aBoneWeight.z * uDualDQ[int(aBoneIndex.z)]; \n   blendDualDQ += aBoneWeight.w * uDualDQ[int(aBoneIndex.w)]; \n   float len = length(blendRealDQ); \n   blendRealDQ /= len; \n   blendDualDQ /= len; \n   vec3 pos = aPosition.xyz; \n   pos.y += uYTrans; \n   pos -= uHeadJointPos; pos *= neckScaleValue; pos += uHeadJointPos; \n   pos = pos.xyz + 2.0*cross(blendRealDQ.xyz, cross(blendRealDQ.xyz, pos.xyz) + blendRealDQ.w*pos.xyz); \n   pos += 2.0*(blendRealDQ.w*blendDualDQ.xyz - blendDualDQ.w*blendRealDQ.xyz + cross(blendRealDQ.xyz, blendDualDQ.xyz)); \n   gl_Position = uMVPMatrix * vec4(pos, 1.0); \n   vTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y); \n   gl_Position.xy += uImageTrans;\n} \n";
    private final String t = "precision lowp float; \nconst vec3 cAmbient = vec3(0.1, 0.1, 0.1); \nconst vec3 cColor = vec3(0.7, 0.7, 0.7); \nconst vec3 cEyePos = vec3(0.0, 0.5, 10.50); \nconst vec3 cLightPos = vec3(0.0, 0.6, 10.50); \nconst vec3 cLightDir = vec3(0.0, 0.0, 1.0); \nuniform vec3       uMaterial; \nuniform vec3       uTone; \nuniform sampler2D  sTexture; \nuniform sampler2D  sTextureShadow; \nuniform sampler2D  sTextureHairy; \nvarying vec2       vTexCoord; \nuniform float      uShadowFactor; \nvoid main() \n{ \n   vec4 shadow = texture2D(sTextureShadow, vTexCoord); \n   vec4 hairy = texture2D(sTextureHairy, vTexCoord); \n   vec4 mainColor = texture2D(sTexture, vTexCoord)*(1.0-hairy.a) + hairy; \n   float mainLumi = (mainColor.r + mainColor.g + mainColor.b)/3.0; \n   mainColor.rgb *= uTone; \n   float tonedLumi = (mainColor.r + mainColor.g + mainColor.b)/3.0; \n   mainColor.rgb *= mainLumi/tonedLumi; \n   if(uShadowFactor > 0.0) \n   { \n       gl_FragColor = mainColor * shadow; \n   } \n   else \n   { \n       gl_FragColor = mainColor; \n   } \n} \n";
    private final String u = "precision highp float; \nuniform mat4   uMVPMatrix; \nuniform mat4   uROTMatrix; \nuniform vec4   uRealDQ[90]; \nuniform vec4   uDualDQ[90]; \nattribute vec4 aBoneWeight; \nattribute vec4 aBoneIndex; \nattribute vec4 aPosition; \nattribute vec2 aTexCoord; \nattribute vec3 aNormal; \nvarying vec2   vTexCoord; \nvarying vec3   vNormal; \nvarying vec3   vPos; \nuniform float  uYTrans; \nuniform float  uHeadScale; \nuniform vec3   uHeadJointPos; \nuniform vec2   uImageTrans; \nvoid main() \n{ \n   vec4 blendRealDQ = vec4(0.0); \n   vec4 blendDualDQ = vec4(0.0); \n   float neckScale = 0.0; \n   float neckScaleValue = uHeadScale; \n   blendRealDQ += aBoneWeight.x * uRealDQ[int(aBoneIndex.x)]; \n   blendRealDQ += aBoneWeight.y * uRealDQ[int(aBoneIndex.y)]; \n   blendRealDQ += aBoneWeight.z * uRealDQ[int(aBoneIndex.z)]; \n   blendRealDQ += aBoneWeight.w * uRealDQ[int(aBoneIndex.w)]; \n   blendDualDQ += aBoneWeight.x * uDualDQ[int(aBoneIndex.x)]; \n   blendDualDQ += aBoneWeight.y * uDualDQ[int(aBoneIndex.y)]; \n   blendDualDQ += aBoneWeight.z * uDualDQ[int(aBoneIndex.z)]; \n   blendDualDQ += aBoneWeight.w * uDualDQ[int(aBoneIndex.w)]; \n   float len = length(blendRealDQ); \n   blendRealDQ /= len; \n   blendDualDQ /= len; \n   vec3 qPos = aPosition.xyz; \n   qPos.y += uYTrans; \n   qPos -= uHeadJointPos; qPos *= neckScaleValue; qPos += uHeadJointPos; \n   qPos = qPos.xyz + 2.0*cross(blendRealDQ.xyz, cross(blendRealDQ.xyz, qPos.xyz) + blendRealDQ.w*qPos.xyz); \n   qPos += 2.0*(blendRealDQ.w*blendDualDQ.xyz - blendDualDQ.w*blendRealDQ.xyz + cross(blendRealDQ.xyz, blendDualDQ.xyz)); \n   gl_Position = uMVPMatrix * vec4(qPos, 1.0); \n   vTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y); \n   vec4 normal = uROTMatrix * vec4(aNormal, 1.0); \n   vNormal = normalize(normal.rgb); \n   vPos = qPos; \n   gl_Position.xy += uImageTrans;\n} \n";
    private final String[] v = {"precision lowp float; \nconst vec3 cEyePos = vec3(0.0, 0.5, 10.50); \nuniform float      uMaterial[13]; \nuniform float      uAlphaThreshold; \nuniform sampler2D  sTexture; \nuniform sampler2D  sTextureSpec; \nvarying vec2       vTexCoord; \nvarying vec3       vNormal; \nvarying vec3       vPos; \nvoid main() \n{ \n   vec4 mainTex = texture2D(sTexture, vTexCoord); \n   vec4 specTex = texture2D(sTextureSpec, vTexCoord); \n   float alpha = mainTex.a; \n   if(alpha < uAlphaThreshold) discard; \n   vec3 L1 = normalize(vPos - vec3(uMaterial[6], uMaterial[7], uMaterial[8])); \n   vec3 L2 = normalize(vPos - vec3(uMaterial[9], uMaterial[10], uMaterial[11])); \n   vec3 L = vec3(uMaterial[3], uMaterial[4], uMaterial[5]); \n   vec3 V = normalize(vPos - cEyePos); \n   vec3 H = normalize((L1 + V)/2.0); \n   vec3 H1 = normalize((L2 + V)/2.0); \n   float DotNL = abs(dot(vNormal, L)); \n   float DotNH = clamp(1.0-abs(dot(vNormal, H)), 0.0, 1.0); \n   float DotNH1 = clamp(1.0-abs(dot(vNormal, H1)), 0.0, 1.0); \n   vec3 albedo = (mainTex.rgb / mainTex.a); \n   vec3 ambient = albedo * uMaterial[0]; \n   vec3 diffuse = albedo * DotNL * uMaterial[1]; \n   vec3 spec = vec3(0.2, 0.2, 0.2) * pow(DotNH, uMaterial[12]) * specTex.r * uMaterial[2] ; \n   vec3 spec1 = vec3(0.2, 0.2, 0.2) * pow(DotNH1, uMaterial[12]) * specTex.r * uMaterial[2] ; \n   gl_FragColor.rgb = (ambient + diffuse + spec + spec1); \n   gl_FragColor.a = alpha; \n} \n", "precision lowp float; \nuniform vec3       uMaterial; \nuniform float      uAlphaThreshold; \nuniform sampler2D  sTexture; \nvarying vec2       vTexCoord; \nvarying vec3       vNormal; \nvarying vec3       vPos; \nvoid main() \n{ \n   vec4 mainTex = texture2D(sTexture, vTexCoord); \n   if(mainTex.a >= uAlphaThreshold || mainTex.a <= 0.001) discard; \n   gl_FragColor.rgb = mainTex.rgb / mainTex.a; \n   gl_FragColor.a = mainTex.a; \n} \n", "precision lowp float; \nconst vec3 cEyePos = vec3(0.0, 0.5, 10.50); \nuniform float      uMaterial[13]; \nuniform float      uAlphaThreshold; \nuniform sampler2D  sTexture; \nvarying vec2       vTexCoord; \nvarying vec3       vNormal; \nvarying vec3       vPos; \nvoid main() \n{ \n   vec4 mainTex = texture2D(sTexture, vTexCoord); \n   vec3 L1 = normalize(vPos - vec3(uMaterial[6], uMaterial[7], uMaterial[8])); \n   vec3 L2 = normalize(vPos - vec3(uMaterial[9], uMaterial[10], uMaterial[11])); \n   vec3 L = vec3(uMaterial[3], uMaterial[4], uMaterial[5]); \n   vec3 V = normalize(vPos - cEyePos); \n   vec3 H = normalize((L1 + V)/2.0); \n   vec3 H1 = normalize((L2 + V)/2.0); \n   float DotNL = abs(dot(vNormal, L)); \n   float DotNH = clamp(1.0-abs(dot(vNormal, H)), 0.0, 1.0); \n   float DotNH1 = clamp(1.0-abs(dot(vNormal, H1)), 0.0, 1.0); \n   vec3 albedo = mainTex.rgb; \n   vec3 ambient = albedo * uMaterial[0]; \n   vec3 diffuse = albedo * DotNL * uMaterial[1]; \n   vec3 spec = vec3(0.2, 0.2, 0.2) * pow(DotNH, uMaterial[12]) * uMaterial[2] ; \n   vec3 spec1 = vec3(0.2, 0.2, 0.2) * pow(DotNH1, uMaterial[12]) * uMaterial[2] ; \n   gl_FragColor.rgb = (ambient + diffuse + spec + spec1); \n   gl_FragColor.a = 1.0; \n} \n"};
    private final String w = "precision highp float; \nuniform mat4   uMVPMatrix; \nuniform float  uPointSize; \nattribute vec4 aPosition; \nvarying float  vDeem; \nuniform vec2   uImageTrans; \nvoid main() \n{ \n   vec4 pos = aPosition; \n   pos.w = 1.0; \n   vDeem = aPosition.w; \n   gl_Position = uMVPMatrix * pos; \n   gl_PointSize = uPointSize; \n   gl_Position.xy += uImageTrans;\n} \n";
    private final String x = "precision highp float; \nuniform vec4   uColor; \nvarying float  vDeem; \nvoid main() \n{ \n   gl_FragColor = uColor*vDeem; \n} \n";
    private b y;
    private n z;
...
```
This is the content for `m.java`. I'll create the file.
